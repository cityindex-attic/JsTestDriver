Index: JsTestDriver/src-test/com/google/jstestdriver/javascript/AssertsTest.js
===================================================================
--- JsTestDriver/src-test/com/google/jstestdriver/javascript/AssertsTest.js	(revision 494)
+++ JsTestDriver/src-test/com/google/jstestdriver/javascript/AssertsTest.js	(working copy)
@@ -301,3 +301,774 @@
   assertEquals("hello", "hello");
   assertEquals(3, jstestdriver.assertCount);
 };
+
+(function () {
+  var GLOBAL = this;
+
+  TestCase("AssertNotEqualsTest", {
+    setUp: function () {
+      this.assertEquals = GLOBAL.assertEquals;
+    },
+
+    tearDown: function () {
+      GLOBAL.assertEquals = this.assertEquals;
+    },
+
+    "test should call assertEquals to compare arguments": function () {
+      GLOBAL.assertEquals = function () { GLOBAL.assertEquals.called = true; };
+
+      try {
+        assertNotEquals(1, 2);
+      } catch (e) {}
+
+      assertTrue(GLOBAL.assertEquals.called);
+    },
+
+    "test should call assertEquals with three arguments": function () {
+      var args = [], expected = 1, actual = 2;
+      GLOBAL.assertEquals = function () { args = arguments; };
+
+      try {
+        assertNotEquals(expected, actual);
+      } catch (e) {}
+
+      this.assertEquals.call(GLOBAL, 2, args.length);
+      this.assertEquals.call(GLOBAL, expected, args[0]);
+      this.assertEquals.call(GLOBAL, actual, args[1]);
+    },
+
+    "test should call assertEquals with original message": function () {
+      var args = [], msg = "oh noes!", expected = 1, actual = 2;
+      GLOBAL.assertEquals = function () { args = arguments; };
+
+      try {
+        assertNotEquals(msg, expected, actual);
+      } catch (e) {}
+
+      this.assertEquals.call(GLOBAL, 3, args.length);
+      this.assertEquals.call(GLOBAL, msg, args[0]);
+    },
+
+    "test should fail when assertEquals passes": function () {
+      GLOBAL.assertEquals = function () {};
+
+      try {
+        assertNotEquals("string1", "string1");
+        fail("assertNotEquals should fail on equal strings");
+      } catch (e) {
+        this.assertEquals.call(GLOBAL, "AssertError", e.name);
+        this.assertEquals.call(GLOBAL, "expected \"string1\" not to be equal to \"string1\"", e.message);
+      }
+    },
+
+    "test should pass when assertEquals fails": function () {
+      GLOBAL.assertEquals = function () {
+        var error = new Error("fail");
+        error.name = "AssertError";
+        throw error;
+      };
+
+      try {
+        assertNotEquals("string2", "string1");
+      } catch (e) {
+        fail("assertNotEquals should pass for unequal strings");
+      }
+    }
+  });
+
+  TestCase("AssertNotNullTest", {
+    "test should fail when null is passed": function () {
+      try {
+        assertNotNull(null);
+        fail("assertNotNull should fail for null");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected not null but was null", e.message);
+      }
+    },
+
+    "test should fail with message when message and null is passed": function () {
+      try {
+        assertNotNull("some value", null);
+        fail("assertNotNull should fail for null");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("some value expected not null but was null", e.message);
+      }
+    },
+
+    "test should pass for undefined": function () {
+      assertNotNull(undefined);
+    },
+
+    "test should pass for object": function () {
+      assertNotNull({});
+    }
+  });
+
+  TestCase("AssertNotUndefinedTest", {
+    "test should fail when undefined is passed": function () {
+      try {
+        assertNotUndefined(undefined);
+        fail("assertNotUndefined should fail for undefined");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected not undefined but was undefined", e.message);
+      }
+    },
+
+    "test should fail with message when message and undefined is passed": function () {
+      try {
+        assertNotUndefined("some value", undefined);
+        fail("assertNotUndefined should fail for undefined");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("some value expected not undefined but was undefined", e.message);
+      }
+    },
+
+    "test should pass for null": function () {
+      assertNotUndefined(null);
+    },
+
+    "test should pass for object": function () {
+      assertNotUndefined({});
+    },
+
+    "test should pass for object with message": function () {
+      assertNotUndefined("object", {});
+    }
+  });
+
+  TestCase("AssertNaNTest", {
+    "test should pass when NaN is passed": function () {
+      assertNaN(10/"o");
+    },
+
+    "test should pass when NaN and message is passed": function () {
+      assertNaN("hope it's NaN", 10/"o");
+    },
+
+    "test should fail when number not NaN is passed": function () {
+      try {
+        assertNaN(10);
+        fail("assertNaN should fail on numbers not NaN");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected to be NaN but was 10", e.message);
+      }
+    },
+
+    "test should fail when message and number not NaN is passed": function () {
+      try {
+        assertNaN("Hope it's NaN!", 10);
+        fail("assertNaN should fail on numbers not NaN");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("Hope it's NaN! expected to be NaN but was 10", e.message);
+      }
+    }
+  });
+
+  TestCase("AssertNotNaNTest", {
+    "test should pass when number is passed": function () {
+      assertNotNaN(10);
+    },
+
+    "test should pass when number and message is passed": function () {
+      assertNotNaN("hope it's not NaN", 10);
+    },
+
+    "test should fail when NaN is passed": function () {
+      try {
+        assertNotNaN(10/"o");
+        fail("assertNotNaN should fail on NaN");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected not to be NaN", e.message);
+      }
+    },
+
+    "test should fail when message and NaN is passed": function () {
+      try {
+        assertNotNaN("Hope it's not NaN!", 10/"o");
+        fail("assertNotNaN should fail on NaN");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("Hope it's not NaN! expected not to be NaN", e.message);
+      }
+    }
+  });
+
+  TestCase("AssertExceptionTest", {
+    "test should pass when callback throws exception": function () {
+      assertException(function () {
+        throw new Error("Fail!");
+      });
+    },
+
+    "test should pass with message when callback throws exception": function () {
+      assertException("Should throw fail error", function () {
+        throw new Error("Fail!");
+      });
+    },
+
+    "test should pass when callback throws correct exception": function () {
+      assertException(function () {
+        throw new Error("Fail!");
+      }, "Error");
+    },
+
+    "test should pass with message when callback throws correct exception": function () {
+      assertException("Should throw fail error", function () {
+        throw new Error("Fail!");
+      }, "Error");
+    },
+
+    "test should fail when callback does not throw exception": function () {
+      try {
+        assertException(function () {});
+        fail("assertException should fail when callback does not throw error");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected to throw exception", e.message);
+      }
+    },
+
+    "test should fail with message when callback does not throw exception": function () {
+      try {
+        assertException("It should fail", function () {});
+        fail("assertException should fail when callback does not throw error");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("It should fail expected to throw exception", e.message);
+      }
+    },
+
+    "test should fail with message and exception type when callback does not throw exception": function () {
+      try {
+        assertException("It should fail", function () {}, "Error");
+        fail("assertException should fail when callback does not throw error");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("It should fail expected to throw exception", e.message);
+      }
+    },
+
+    "test should fail when exception thrown is not of correct type": function () {
+      try {
+        assertException(function () { throw new TypeError(); }, "Error");
+        fail("assertException should fail when callback does not throw error");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected to throw Error but threw TypeError", e.message);
+      }
+    },
+
+    "test should fail with message when exception thrown is not of correct type": function () {
+      try {
+        assertException("It should fail", function () { throw new TypeError(); }, "Error");
+        fail("assertException should fail when callback does not throw error");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("It should fail expected to throw Error but threw TypeError", e.message);
+      }
+    }
+  });
+
+  TestCase("AssertNoExceptionTest", {
+    "test should pass when callback does not throw exception": function () {
+      assertNoException(function () {});
+    },
+
+    "test should pass with message when callback does not throw exception": function () {
+      assertNoException("It should pass", function () {});
+    },
+
+    "test should fail when callback throws exception": function () {
+      try {
+        assertNoException(function () { throw new Error("Oh no!"); });
+        fail("assertNoException should fail when callback throws error");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected not to throw exception, but threw Error (Oh no!)", e.message);
+      }
+    },
+
+    "test should fail with message when callback throws exception": function () {
+      try {
+        assertNoException("It should pass", function () { throw new Error("Oh no!"); });
+        fail("assertNoException should fail when callback throws error");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("It should pass expected not to throw exception, but threw Error (Oh no!)", e.message);
+      }
+    }
+  });
+
+  TestCase("AssertArrayTest", {
+    setUp: function () {
+      this.isArray = jstestdriver.jQuery.isArray;
+    },
+
+    tearDown: function () {
+      jstestdriver.jQuery.isArray = this.isArray;
+    },
+
+    "test should check arrayness with jstestdriver.jQuery.isArray": function () {
+      var called;
+      jstestdriver.jQuery.isArray = function () { return (called = true); };
+      assertArray([]);
+
+      assertTrue(called);
+    },
+
+    "test should pass when isArray returns true": function () {
+      jstestdriver.jQuery.isArray = function () { return true; };
+      assertArray([]);
+    },
+
+    "test should pass with message when isArray returns true": function () {
+      jstestdriver.jQuery.isArray = function () { return true; };
+      assertArray("should be array", []);
+    },
+
+    "test should fail when isArray returns false": function () {
+      jstestdriver.jQuery.isArray = function () { return false; };
+
+      try {
+        assertArray({});
+        fail("assertArray should fail when isArray returns false");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected to be array but was {}");
+      }
+    },
+
+    "test should fail with message when isArray returns false": function () {
+      jstestdriver.jQuery.isArray = function () { return false; };
+
+      try {
+        assertArray("no array", {});
+        fail("assertArray should fail when isArray returns false");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("no array expected to be array but was {}");
+      }
+    }
+  });
+
+  TestCase("AssertTypeOfTest", {
+    "test pass for correct type": function () {
+      assertTypeOf("string", "string string string");
+    },
+
+    "test pass with message for correct type": function () {
+      assertTypeOf("string should be, well, string", "string", "string string string");
+    },
+
+    "test fail for wrong type": function () {
+      try {
+        assertTypeOf("object", "string string string");
+        fail("assertTypeOf should fail for wrong type");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected to be object but was string");
+      }
+    },
+
+    "test fail with message for wrong type": function () {
+      try {
+        assertTypeOf("should fail", "object", "string string string");
+        fail("assertTypeOf should fail for wrong type");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("should fail expected to be object but was string", e.message);
+      }
+    }
+  });
+
+  TestCase("AssertTypeOfApplicationsTest", {
+    setUp: function () {
+      this.assertTypeOf = GLOBAL.assertTypeOf;
+    },
+
+    tearDown: function () {
+      GLOBAL.assertTypeOf = this.assertTypeOf;
+    },
+
+    "test assertBoolean should delegate to assertTypeOf": function () {
+      var args, actual = "some value";
+      GLOBAL.assertTypeOf = function () { args = [].slice.call(arguments); };
+      assertBoolean(actual);
+
+      assertEquals(["", "boolean", actual], args);
+    },
+
+    "test assertBoolean should delegate to assertTypeOf with message": function () {
+      var args, actual = "some value", msg = "should be boolean";
+      GLOBAL.assertTypeOf = function () { args = [].slice.call(arguments); };
+      assertBoolean(msg, actual);
+
+      assertEquals([msg + " ", "boolean", actual], args);
+    },
+
+    "test assertFunction should delegate to assertTypeOf": function () {
+      var args, actual = "some value";
+      GLOBAL.assertTypeOf = function () { args = [].slice.call(arguments); };
+      assertFunction(actual);
+
+      assertEquals(["", "function", actual], args);
+    },
+
+    "test assertFunction should delegate to assertTypeOf with message": function () {
+      var args, actual = "some value", msg = "should be function";
+      GLOBAL.assertTypeOf = function () { args = [].slice.call(arguments); };
+      assertFunction(msg, actual);
+
+      assertEquals([msg + " ", "function", actual], args);
+    },
+
+    "test assertNumber should delegate to assertTypeOf": function () {
+      var args, actual = "some value";
+      GLOBAL.assertTypeOf = function () { args = [].slice.call(arguments); };
+      assertNumber(actual);
+
+      assertEquals(["", "number", actual], args);
+    },
+
+    "test assertNumber should delegate to assertTypeOf with message": function () {
+      var args, actual = "some value", msg = "should be number";
+      GLOBAL.assertTypeOf = function () { args = [].slice.call(arguments); };
+      assertNumber(msg, actual);
+
+      assertEquals([msg + " ", "number", actual], args);
+    },
+
+    "test assertObject should delegate to assertTypeOf": function () {
+      var args, actual = "some value";
+      GLOBAL.assertTypeOf = function () { args = [].slice.call(arguments); };
+      assertObject(actual);
+
+      assertEquals(["", "object", actual], args);
+    },
+
+    "test assertObject should delegate to assertTypeOf with message": function () {
+      var args, actual = "some value", msg = "should be object";
+      GLOBAL.assertTypeOf = function () { args = [].slice.call(arguments); };
+      assertObject(msg, actual);
+
+      assertEquals([msg + " ", "object", actual], args);
+    },
+
+    "test assertString should delegate to assertTypeOf": function () {
+      var args, actual = "some value";
+      GLOBAL.assertTypeOf = function () { args = [].slice.call(arguments); };
+      assertString(actual);
+
+      assertEquals(["", "string", actual], args);
+    },
+
+    "test assertString should delegate to assertTypeOf with message": function () {
+      var args, actual = "some value", msg = "should be string";
+      GLOBAL.assertTypeOf = function () { args = [].slice.call(arguments); };
+      assertString(msg, actual);
+
+      assertEquals([msg + " ", "string", actual], args);
+    }
+  });
+
+  TestCase("AssertMatchTest", {
+    "test should pass when string matches regexp": function () {
+      assertMatch(/hello/, "oh, hello there");
+    },
+
+    "test should pass with message when string matches regexp": function () {
+      assertMatch("should match hello", /hello/, "oh, hello there");
+    },
+
+    "test should fail if actual argument is not given": function () {
+      try {
+        assertMatch(/oh no/);
+        fail("assertMatch should fail when missing string");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected atleast 2 arguments, got 1", e.message);
+      }
+    },
+
+    "test should fail if actual argument is undefined": function () {
+      try {
+        assertMatch(/oh no/, undefined);
+        fail("assertMatch should fail when missing string");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected undefined to match /oh no/", e.message);
+      }
+    },
+
+    "test should fail when string does not match regexp": function () {
+      try {
+        assertMatch(/oh no/, "hell yes");
+        fail("assertMatch should fail when string doesn't match regexp");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected \"hell yes\" to match /oh no/", e.message);
+      }
+    },
+
+    "test should fail with message when string does not match regexp": function () {
+      try {
+        assertMatch("will fail", /oh no/, "hell yes");
+        fail("assertMatch should fail when string doesn't match regexp");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("will fail expected \"hell yes\" to match /oh no/", e.message);
+      }
+    }
+  });
+
+  TestCase("AssertNoMatchTest", {
+    "test should pass when string does not matches regexp": function () {
+      assertNoMatch(/hello/, "oh, y'ello there");
+    },
+
+    "test should pass with message when string does not matches regexp": function () {
+      assertNoMatch("should match hello", /hello/, "oh, y'ello there");
+    },
+
+    "test should pass when actual argument is undefined": function () {
+      assertNoMatch("should match hello", /hello/, undefined);
+    },
+
+    "test should fail when string matches regexp": function () {
+      try {
+        assertNoMatch(/oh no/, "oh no");
+        fail("assertNoMatch should fail when string matches regexp");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected \"oh no\" not to match /oh no/", e.message);
+      }
+    },
+
+    "test should fail with message when string matches regexp": function () {
+      try {
+        assertNoMatch("will fail", /oh no/, "oh no");
+        fail("assertNoMatch should fail when string matches regexp");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("will fail expected \"oh no\" not to match /oh no/", e.message);
+      }
+    }
+  });
+
+  TestCase("AssertTagNameTest", {
+    setUp: function () {
+      /*:DOC += <div id="el"></div> */
+      this.element = document.getElementById("el");
+    },
+
+    "test should pass when tag name is correct": function () {
+      assertTagName("div", this.element);
+    },
+
+    "test should pass tag name regardless of casing": function () {
+      assertTagName("DIV", this.element);
+    },
+
+    "test should pass with message when tag name is correct": function () {
+      assertTagName("should be div", "div", this.element);
+    },
+
+    "test should fail for wrong tag name": function () {
+      try {
+        assertTagName("span", this.element);
+        fail("assertTagName should fail for wrong tag name");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected tagName to be span but was DIV", e.message);
+      }
+    },
+
+    "test should fail with message for wrong tag name": function () {
+      try {
+        assertTagName("should be span", "span", this.element);
+        fail("assertTagName should fail for wrong tag name");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("should be span expected tagName to be span but was DIV", e.message);
+      }
+    }
+  });
+
+  TestCase("AssertClassNameTest", {
+    setUp: function () {
+      /*:DOC += <div id="el" class="something"></div> */
+      /*:DOC += <div id="el2" class="something other"></div> */
+      /*:DOC += <div id="el3"></div> */
+      this.element = document.getElementById("el");
+      this.elementMultipleClasses = document.getElementById("el2");
+      this.elementNoClass = document.getElementById("el3");
+    },
+
+    "test should pass when class name is correct": function () {
+      assertClassName("something", this.element);
+    },
+
+    "test should pass with message when class name is correct": function () {
+      assertClassName("should have something", "something", this.element);
+    },
+
+    "test should pass when class name contains expected class name": function () {
+      assertClassName("should have something", "something", this.elementMultipleClasses);
+      assertClassName("should have something", "other", this.elementMultipleClasses);
+    },
+
+    "test should fail for missing class name": function () {
+      try {
+        assertClassName("hola", this.element);
+        fail("assertClassName should fail for missing class name");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected class name to include \"hola\" but was \"something\"", e.message);
+      }
+    },
+
+    "test should fail with message for missing class name": function () {
+      try {
+        assertClassName("msg", "hola", this.element);
+        fail("assertClassName should fail for missing class name");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("msg expected class name to include \"hola\" but was \"something\"", e.message);
+      }
+    },
+
+    "test should fail when element has no classes": function () {
+      try {
+        assertClassName("hola", this.elementNoClass);
+        fail("assertClassName should fail for missing class name");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected class name to include \"hola\" but was \"\"", e.message);
+      }
+    },
+
+    "test should fail with message when element has no classes": function () {
+      try {
+        assertClassName("msg", "hola", this.elementNoClass);
+        fail("assertClassName should fail for missing class name");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("msg expected class name to include \"hola\" but was \"\"", e.message);
+      }
+    }
+  });
+
+  TestCase("AssertElementIdTest", {
+    setUp: function () {
+      /*:DOC += <div id="el"></div> */
+      this.element = document.getElementById("el");
+    },
+
+    "test should pass when id is correct": function () {
+      assertElementId("el", this.element);
+    },
+
+    "test should pass with message when id is correct": function () {
+      assertElementId("should be el", "el", this.element);
+    },
+
+    "test should fail for wrong id": function () {
+      try {
+        assertElementId("other", this.element);
+        fail("assertElementId should fail for wrong id");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("expected id to be other but was el", e.message);
+      }
+    },
+
+    "test should fail with message for wrong id": function () {
+      try {
+        assertElementId("should be span", "span", this.element);
+        fail("assertElementId should fail for wrong id");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertEquals("should be span expected id to be span but was el", e.message);
+      }
+    }
+  });
+
+  TestCase("AssertInstanceOfTest", {
+    "test should pass when object is instance of constructor": function () {
+      assertInstanceOf(String, "a string");
+    },
+
+    "test should pass with message when object is instance of constructor": function () {
+      assertInstanceOf("should be string", String, "a string");
+    },
+
+    "test should fail if object is not instance of constructor": function () {
+      function MyConstructor () {};
+
+      try {
+        assertInstanceOf(MyConstructor, {});
+        fail("assertInstanceOf should fail if object is not instance of constructor");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertMatch(/expected {} to be instance of .*MyConstructor.*/, e.message);
+      }
+    },
+
+    "test should fail with message if object is not instance of constructor": function () {
+      function MyConstructor () {};
+
+      try {
+        assertInstanceOf("msg", MyConstructor, {});
+        fail("assertInstanceOf should fail if object is not instance of constructor");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertMatch(/msg expected {} to be instance of .*MyConstructor.*/, e.message);
+      }
+    }
+  });
+
+  TestCase("AssertNotInstanceOfTest", {
+    "test should pass when object is not instance of constructor": function () {
+      assertNotInstanceOf(Array, "a string");
+    },
+
+    "test should pass with message when object is not instance of constructor": function () {
+      assertNotInstanceOf("should be string", Array, "a string");
+    },
+
+    "test should fail if object is instance of constructor": function () {
+      try {
+        assertNotInstanceOf(Object, {});
+        fail("assertNotInstanceOf should fail if object is instance of constructor");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertMatch(/expected {} not to be instance of /, e.message);
+        assertMatch(/Object/, e.message);
+      }
+    },
+
+    "test should fail with message if object is instance of constructor": function () {
+      try {
+        assertNotInstanceOf("msg", Object, {});
+        fail("assertNotInstanceOf should fail if object is instance of constructor");
+      } catch (e) {
+        assertEquals("AssertError", e.name);
+        assertMatch(/msg expected {} not to be instance of /, e.message);
+        assertMatch(/Object/, e.message);
+      }
+    }
+  });
+
+  TestCase("AssertTest", {
+    "test should alias assertTrue as assert": function () {
+      assertEquals(assertTrue, assert);
+    }
+  });
+}());
Index: JsTestDriver/src/com/google/jstestdriver/javascript/Asserts.js
===================================================================
--- JsTestDriver/src/com/google/jstestdriver/javascript/Asserts.js	(revision 494)
+++ JsTestDriver/src/com/google/jstestdriver/javascript/Asserts.js	(working copy)
@@ -13,12 +13,12 @@
  * License for the specific language governing permissions and limitations under
  * the License.
  */
-expectAsserts = function(count){
+function expectAsserts (count){
   jstestdriver.expectedAssertCount = count;
 };
 
 
-fail = function(msg) {
+function fail (msg) {
   var err = new Error(msg);
 
   err.name = 'AssertError';
@@ -26,14 +26,14 @@
 };
 
 
-isBoolean_ = function(bool) {
+function isBoolean_ (bool) {
   if (typeof(bool) != 'boolean') {
     fail('Not a boolean: ' + this.prettyPrintEntity_(bool));
   }
 };
 
 
-prettyPrintEntity_ = function(entity) {
+function prettyPrintEntity_ (entity) {
   var str = JSON.stringify(entity);
   if (!str) {
     if (typeof entity === 'function') {
@@ -45,41 +45,46 @@
 };
 
 
-assertTrue = function(msg, actual) {
-  if (arguments.length == 1) {
-    actual = msg;
-    msg = '';
+function argsWithOptionalMsg_ (args, length) {
+  var min = length - 1;
+
+  if (args.length < min) {
+    fail("expected atleast " + min + " arguments, got " + args.length);
+  } else if (args.length == length) {
+    args[0] += " ";
   } else {
-    msg += ' ';
+    [].unshift.call(args, "");
   }
+
+  return args;
+}
+
+
+function assertTrue (msg, actual) {
+  var args = argsWithOptionalMsg_(arguments, 2);
   jstestdriver.assertCount++;
 
-  isBoolean_(actual);
-  if (actual != true) {
-    fail(msg + 'expected true but was ' + this.prettyPrintEntity_(actual) + '');
+  isBoolean_(args[1]);
+  if (args[1] != true) {
+    fail(args[0] + 'expected true but was ' + this.prettyPrintEntity_(args[1]));
   }
   return true;
 };
 
 
-assertFalse = function(msg, actual) {
-  if (arguments.length == 1) {
-    actual = msg;
-    msg = '';
-  } else {
-    msg += ' ';
-  }
+function assertFalse (msg, actual) {
+  var args = argsWithOptionalMsg_(arguments, 2);
   jstestdriver.assertCount++;
 
-  isBoolean_(actual);
-  if (actual != false) {
-    fail(msg + 'expected false but was ' + this.prettyPrintEntity_(actual) + '');
+  isBoolean_(args[1]);
+  if (args[1] != false) {
+    fail(args[0] + 'expected false but was ' + this.prettyPrintEntity_(args[1]));
   }
   return true;
 };
 
 
-assertEquals = function(msg, expected, actual) {
+function assertEquals (msg, expected, actual) {
   if (arguments.length == 2) {
     var tmp = expected;
 
@@ -153,110 +158,321 @@
 };
 
 
-assertSame = function(msg, expected, actual) {
-  if (arguments.length == 2) {
-    var tmp = expected;
+function assertNotEquals (msg, expected, actual) {
+  try {
+    assertEquals.apply(this, arguments);
+  } catch (e) {
+    if (e.name == "AssertError") {
+      return true;
+    }
 
-    expected = msg;
-    actual = tmp;
-    msg = '';
-  } else {
-    msg += ' ';
+    throw e;
   }
+
+  var args = argsWithOptionalMsg_(arguments, 3);
+
+  fail(msg + "expected " + prettyPrintEntity_(args[1]) + " not to be equal to " +
+       prettyPrintEntity_(args[2]));
+}
+
+
+function assertSame (msg, expected, actual) {
+  var args = argsWithOptionalMsg_(arguments, 3);
   jstestdriver.assertCount++;
 
-  if (!isSame_(actual, expected)) {
-    fail(msg + 'expected ' + this.prettyPrintEntity_(expected) + ' but was ' +
-        this.prettyPrintEntity_(actual) + '');
+  if (!isSame_(args[2], args[1])) {
+    fail(args[0] + 'expected ' + this.prettyPrintEntity_(args[1]) + ' but was ' +
+        this.prettyPrintEntity_(args[2]));
   }
   return true;
 };
 
 
-assertNotSame = function(msg, expected, actual) {
-  if (arguments.length == 2) {
-    var tmp = expected;
-
-    expected = msg;
-    actual = tmp;
-    msg = '';
-  } else {
-    msg += ' ';
-  }  
+function assertNotSame (msg, expected, actual) {
+  var args = argsWithOptionalMsg_(arguments, 3);
   jstestdriver.assertCount++;
 
-  if (isSame_(actual, expected)) {
-    fail(msg + 'expected not same as ' + this.prettyPrintEntity_(expected) + ' but was ' +
-        this.prettyPrintEntity_(actual) + '');
+  if (isSame_(args[2], args[1])) {
+    fail(args[0] + 'expected not same as ' + this.prettyPrintEntity_(args[1]) + ' but was ' +
+        this.prettyPrintEntity_(args[2]));
   }
   return true;
 };
 
 
-isSame_ = function(expected, actual) {
+function isSame_ (expected, actual) {
   return actual === expected;
 };
 
 
-assertNull = function(msg, actual) {
-  if (arguments.length == 1) {
-    actual = msg;
-    msg = '';
-  } else {
-    msg += ' ';
-  }
+function assertNull (msg, actual) {
+  var args = argsWithOptionalMsg_(arguments, 2);
   jstestdriver.assertCount++;
 
-  if (actual !== null) {
-    fail(msg + 'expected null but was ' + this.prettyPrintEntity_(actual) + '');
+  if (args[1] !== null) {
+    fail(args[0] + 'expected null but was ' + this.prettyPrintEntity_(args[1]));
   }
   return true;
 };
 
 
-assertNotNull = function(msg, actual) {
-  if (arguments.length == 1) {
-    actual = msg;
-    msg = '';
-  } else {
-    msg += ' ';
-  }
+function assertNotNull (msg, actual) {
+  var args = argsWithOptionalMsg_(arguments, 2);
   jstestdriver.assertCount++;
 
-  if (actual === null) {
-    fail(msg + 'expected not null but was ' + this.prettyPrintEntity_(actual) + '');
+  if (args[1] === null) {
+    fail(args[0] + "expected not null but was null");
   }
+
   return true;
 };
 
 
-assertUndefined = function(msg, actual) {
-  if (arguments.length == 1) {
-    actual = msg;
-    msg = '';
-  } else {
-    msg += ' ';
-  }
+function assertUndefined (msg, actual) {
+  var args = argsWithOptionalMsg_(arguments, 2);
   jstestdriver.assertCount++;
 
-  if (actual !== undefined) {
-    fail(msg + 'expected undefined but was ' + this.prettyPrintEntity_(actual) + '');
+  if (typeof args[1] != "undefined") {
+    fail(args[2] + "expected undefined but was " + this.prettyPrintEntity_(args[1]));
   }
   return true;
 };
 
 
-assertNotUndefined = function(msg, actual) {
-  if (arguments.length == 1) {
-    actual = msg;
-    msg = '';
-  } else {
-    msg += ' ';
-  }
+function assertNotUndefined (msg, actual) {
+  var args = argsWithOptionalMsg_(arguments, 2);
   jstestdriver.assertCount++;
 
-  if (actual === undefined) {
-    fail(msg + 'expected not undefined but was ' + this.prettyPrintEntity_(actual) + '');
+  if (typeof args[1] == "undefined") {
+    fail(args[0] + 'expected not undefined but was undefined');
   }
   return true;
 };
+
+
+function assertNaN (msg, actual) {
+    var args = argsWithOptionalMsg_(arguments, 2);
+    jstestdriver.assertCount++;
+
+    if (!isNaN(args[1])) {
+        fail(args[0] + "expected to be NaN but was " + args[1]);
+    }
+
+    return true;
+}
+
+
+function assertNotNaN (msg, actual) {
+    var args = argsWithOptionalMsg_(arguments, 2);
+    jstestdriver.assertCount++;
+
+    if (isNaN(args[1])) {
+        fail(args[0] + "expected not to be NaN");
+    }
+
+    return true;
+}
+
+
+function assertException(msg, callback, error) {
+    if (arguments.length == 1) {
+        // assertThrows(callback)
+        callback = msg;
+        msg = "";
+    } else if (arguments.length == 2) {
+        if (typeof callback != "function") {
+            // assertThrows(callback, type)
+            error = callback;
+            callback = msg;
+            msg = "";
+        } else {
+            // assertThrows(msg, callback)
+            msg += " ";
+        }
+    } else {
+        // assertThrows(msg, callback, type)
+        msg += " ";
+    }
+
+    jstestdriver.assertCount++;
+
+    try {
+        callback();
+    } catch(e) {
+        if (e.name == "AssertError") {
+            throw e;
+        }
+
+        if (error && e.name != error) {
+            fail(msg + "expected to throw " + error + " but threw " + e.name);
+        }
+
+        return true;
+    }
+
+    fail(msg + "expected to throw exception");
+}
+
+
+function assertNoException(msg, callback) {
+    var args = argsWithOptionalMsg_(arguments, 2);
+    jstestdriver.assertCount++;
+
+    try {
+        args[1]();
+    } catch(e) {
+        fail(args[0] + "expected not to throw exception, but threw " + e.name + " (" + e.message + ")");
+    }
+}
+
+
+function assertArray (msg, actual) {
+    var args = argsWithOptionalMsg_(arguments, 2);
+    jstestdriver.assertCount++;
+
+    if (!jstestdriver.jQuery.isArray(args[1])) {
+        fail(args[0] + "expected to be array, but was " + prettyPrintEntity_(args[1]));
+    }
+}
+
+
+function assertTypeOf (msg, expected, value) {
+    var args = argsWithOptionalMsg_(arguments, 3);
+    jstestdriver.assertCount++;
+    var actual = typeof args[2];
+
+    if (actual != args[1]) {
+        fail(args[0] + "expected to be " + args[1] + " but was " + actual);
+    }
+
+    return true;
+}
+
+
+function assertBoolean (msg, actual) {
+    var args = argsWithOptionalMsg_(arguments, 2);
+    return assertTypeOf(args[0], "boolean", args[1]);
+}
+
+
+function assertFunction (msg, actual) {
+    var args = argsWithOptionalMsg_(arguments, 2);
+    return assertTypeOf(args[0], "function", args[1]);
+}
+
+
+function assertObject (msg, actual) {
+    var args = argsWithOptionalMsg_(arguments, 2);
+    return assertTypeOf(args[0], "object", args[1]);
+}
+
+
+function assertNumber (msg, actual) {
+    var args = argsWithOptionalMsg_(arguments, 2);
+    return assertTypeOf(args[0], "number", args[1]);
+}
+
+
+function assertString (msg, actual) {
+    var args = argsWithOptionalMsg_(arguments, 2);
+    return assertTypeOf(args[0], "string", args[1]);
+}
+
+
+function assertMatch (msg, regexp, actual) {
+    var args = argsWithOptionalMsg_(arguments, 3);
+    var isUndef = typeof args[2] == "undefined";
+    jstestdriver.assertCount++;
+
+    if (isUndef || !args[1].test(args[2])) {
+        actual = (isUndef ? undefined : prettyPrintEntity_(args[2]));
+        fail(args[0] + "expected " + actual + " to match " + args[1]);
+    }
+
+    return true;
+}
+
+
+function assertNoMatch (msg, regexp, actual) {
+    var args = argsWithOptionalMsg_(arguments, 3);
+    jstestdriver.assertCount++;
+
+    if (args[1].test(args[2])) {
+        fail(args[0] + "expected " + prettyPrintEntity_(args[2]) + " not to match " + args[1]);
+    }
+
+    return true;
+}
+
+
+function assertTagName (msg, tagName, element) {
+    var args = argsWithOptionalMsg_(arguments, 3);
+    var actual = args[2] && args[2].tagName;
+
+    try {
+        assertMatch(args[0], new RegExp(tagName, "i"), actual);
+    } catch (e) {
+        fail(args[0] + "expected tagName to be " + args[1] + " but was " + actual);
+    }
+
+    return true;
+}
+
+
+function assertClassName (msg, className, element) {
+    var args = argsWithOptionalMsg_(arguments, 3);
+    var actual = args[2] && args[2].className;
+    var regexp = new RegExp("(^|\\s)" + args[1] + "(\\s|$)");
+
+    try {
+        assertMatch(args[0], regexp, actual);
+    } catch (e) {
+        actual = prettyPrintEntity_(actual);
+        fail(args[0] + "expected class name to include " + prettyPrintEntity_(args[1]) + " but was " + actual);
+    }
+
+    return true;
+}
+
+
+function assertElementId (msg, id, element) {
+    var args = argsWithOptionalMsg_(arguments, 3);
+    var actual = args[2] && args[2].id;
+    jstestdriver.assertCount++;
+
+    if (actual !== args[1]) {
+        fail(args[0] + "expected id to be " + args[1] + " but was " + actual);
+    }
+
+    return true;
+}
+
+
+function assertInstanceOf (msg, constructor, actual) {
+    var args = argsWithOptionalMsg_(arguments, 3);
+    jstestdriver.assertCount++;
+
+    if (!(Object(args[2]) instanceof args[1])) {
+        var expected = args[1] && args[1].name || args[1];
+        var pretty = prettyPrintEntity_(args[2]);
+        fail(args[0] + "expected " + pretty + " to be instance of " + expected);
+    }
+
+    return true;
+}
+
+
+function assertNotInstanceOf (msg, constructor, actual) {
+    var args = argsWithOptionalMsg_(arguments, 3);
+    jstestdriver.assertCount++;
+
+    if (Object(args[2]) instanceof args[1]) {
+        var expected = args[1] && args[1].name || args[1];
+        var pretty = prettyPrintEntity_(args[2]);
+        fail(args[0] + "expected " + pretty + " not to be instance of " + expected);
+    }
+
+    return true;
+}
+
+var assert = assertTrue;
